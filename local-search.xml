<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法D&amp;C</title>
    <link href="/2020/09/07/%E7%AE%97%E6%B3%95D-C/"/>
    <url>/2020/09/07/%E7%AE%97%E6%B3%95D-C/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 算法D&amp;C<br>author: 小胡<br>tags:</p><p>正文：</p><hr><h1 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h1><h2 id="D-amp-C直观示例："><a href="#D-amp-C直观示例：" class="headerlink" title="D&amp;C直观示例："></a>D&amp;C直观示例：</h2><p>假设你是农场主，有一块土地。</p><p>你要将这块地均匀的分成方块，且分出的方块要尽可能大。显然，下面的分法都不符合要求。</p><p>如何将一块地均匀地分成方块，并确保分出方块是最大的呢？使用D&amp;C策略！D&amp;C算法是递归的。使用D&amp;C解决问题的过程包括两个步骤。</p><h3 id="1-1找出基线条件，这种条件必须可能简单"><a href="#1-1找出基线条件，这种条件必须可能简单" class="headerlink" title="1.1找出基线条件，这种条件必须可能简单"></a>1.1<em>找出基线条件，这种条件必须可能简单</em></h3><h3 id="2-2不断将问题分解（或者说缩小规模），直到符合基线条件。"><a href="#2-2不断将问题分解（或者说缩小规模），直到符合基线条件。" class="headerlink" title="2.2不断将问题分解（或者说缩小规模），直到符合基线条件。"></a><em>2.2不断将问题分解（或者说缩小规模），直到符合基线条件</em>。</h3><h4 id="下面就来使用D-amp-C找出前述问题的解决方案。可你能使用的最大方块有多大呢？"><a href="#下面就来使用D-amp-C找出前述问题的解决方案。可你能使用的最大方块有多大呢？" class="headerlink" title="下面就来使用D&amp;C找出前述问题的解决方案。可你能使用的最大方块有多大呢？"></a>下面就来使用D&amp;C找出前述问题的解决方案。可你能使用的最大方块有多大呢？</h4><h4 id="首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。"><a href="#首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。" class="headerlink" title="首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。"></a>首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。</h4><p>如果一边长25 m，另一边长50 m，那么可使用的最大方块为 25 m×25 m。换言之，可以将这块地分成两个这样的方块。</p><p>现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出这块地可容纳的最大方块。</p><p>你可以从这块地中划出两个640 m×640 m的方块，同时余下一小块地。现在是顿悟时刻：何不对余下的那一小块地使用相同的算法呢？</p><h4 id="最初要划分的土地尺寸为1680-m×640-m，而现在要划分的土地更小，为640-m×400-m。-适用于这小块地的最大方块，也是适用于整块地的最大方块-。换言之，你将均匀划分1680-m×640-m土地的问题，简化成了均匀划分640m-400m土地的问题"><a href="#最初要划分的土地尺寸为1680-m×640-m，而现在要划分的土地更小，为640-m×400-m。-适用于这小块地的最大方块，也是适用于整块地的最大方块-。换言之，你将均匀划分1680-m×640-m土地的问题，简化成了均匀划分640m-400m土地的问题" class="headerlink" title="最初要划分的土地尺寸为1680 m×640 m，而现在要划分的土地更小，为640 m×400 m。**适用于这小块地的最大方块，也是适用于整块地的最大方块** 。换言之，你将均匀划分1680 m×640 m土地的问题，简化成了均匀划分640m*400m土地的问题"></a>最初要划分的土地尺寸为1680 m×640 m，而现在要划分的土地更小，为640 m×400 m。**<em>适用于这小块地的最大方块，也是适用于整块地的最大方块**</em> 。换言之，你将均匀划分1680 m×640 m土地的问题，简化成了均匀划分640m*400m土地的问题</h4><p>下面再次使用同样的算法，对于640m×400m的土地，可从中划出最大400m×400m.这将余下一块更小的土地，其尺寸为400m×240m，同理你又可以划出最大方块，余下更小的土地，其尺寸为240m ×160m.接下来，一直递归同样的方法。直到满足基线条件，即160m×80m，因为160m是80m的整数倍。</p><p>因此对于最初的那片土地，适用的最大方块为80m×80m.</p><h2 id="这里重申一下D-amp-C的工作原理："><a href="#这里重申一下D-amp-C的工作原理：" class="headerlink" title="这里重申一下D&amp;C的工作原理："></a>这里重申一下D&amp;C的工作原理：</h2><p>1.1找出简单的基线条件；</p><p>2.2确定如何缩小问题的规模，使其符合基线条件。</p><h2 id="本文引自-lt-lt-算法图解-gt-gt-示例。"><a href="#本文引自-lt-lt-算法图解-gt-gt-示例。" class="headerlink" title="本文引自&lt;&lt;算法图解&gt;&gt;示例。"></a><em>本文引自&lt;&lt;算法图解&gt;&gt;示例。</em></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/09/05/MyBatis%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/09/05/MyBatis%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>title: MyBatis的学习笔记<br>date: 2020-09-05 17:49:19<br>tags:</p><h1 id="1-Mybatis的Dao层实现"><a href="#1-Mybatis的Dao层实现" class="headerlink" title="1.Mybatis的Dao层实现"></a>1.Mybatis的Dao层实现</h1><h2 id="1-1传统的开发方式"><a href="#1-1传统的开发方式" class="headerlink" title="1.1传统的开发方式"></a>1.1传统的开发方式</h2><p>1.1.1编写UserDao接口</p><pre><code class="hljs java">`<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;`    `<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;``&#125;`</code></pre><p>1.1.1编写UserDaoImpl实现类</p><pre><code class="hljs java">`<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;`    `<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;`        `InputStream resourceAsStream =`                     `Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);`        `SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span>`                     `SqlSessionFactoryBuilder().build(resourceAsStream);`        `SqlSession sqlSession = sqlSessionFactory.openSession();`        `List&lt;User&gt; userList = sqlSession.selectList(<span class="hljs-string">&quot;userMapper.findAll&quot;</span>);`        `sqlSession.close();`        `<span class="hljs-keyword">return</span> userList;`    `&#125;``&#125;`</code></pre><p>1.1.3测试传统方式</p><pre><code class="hljs java">`<span class="hljs-meta">@Test</span>``<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTraditionDao</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;`    `UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();`    `List&lt;User&gt; all = userDao.findAll();`    `System.out.println(all);``&#125;`</code></pre><h3 id="1-2代理开发方式"><a href="#1-2代理开发方式" class="headerlink" title="1.2代理开发方式"></a>1.2代理开发方式</h3><p>1.2.1代理开发方式介绍</p><p>采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。</p><p>Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。</p><p>Mapper接口开发需要遵循以下规范：</p><p><strong>1) Mapper.xml文件中的namespace与mapper接口的全限定名相同</strong></p><p><strong>2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同</strong></p><p><strong>3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</strong></p><p><strong>4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</strong></p><h2 id="2-MyBatis映射文件"><a href="#2-MyBatis映射文件" class="headerlink" title="2.MyBatis映射文件"></a>2.MyBatis映射文件</h2><p>2.1动态的sql语句</p><p>2.1.1<if>标签</p><p>我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。</p><select id="findByCondition" parameterType="user" resultType="user">    select * from User    <where>        <if test="id!=0">            and id=#{id}        </if>        <if test="username!=null">            and username=#{username}        </if>    </where></select>2.1.2<forEach>标签<select id="findByIds" parameterType="list" resultType="user">    select * from User    <where>        <foreach collection="array" open="id in(" close=")" item="id" separator=",">            #{id}        </foreach>    </where></select><p>循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。</p><p>foreach标签的属性含义如下：</p><p><foreach>标签用于遍历集合，它的属性：</p><p>•collection：代表要遍历的集合元素，注意编写时不要写#{}</p><p>•open：代表语句的开始部分</p><p>•close：代表结束部分</p><p>•item：代表遍历集合的每个元素，生成的变量名</p><p>•sperator：代表分隔符</p><h2 id="2-2sql片段的抽取"><a href="#2-2sql片段的抽取" class="headerlink" title="2.2sql片段的抽取"></a>2.2sql片段的抽取</h2><p>sql中有重复的sql抽取出来，方便维护，减少代码的冗余性。。使用include标签即可。</p><h3 id="3-plugins标签"><a href="#3-plugins标签" class="headerlink" title="3.plugins标签"></a>3.plugins标签</h3><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据</p><p>开发步骤：</p><p>①导入通用PageHelper的坐标</p><p>②在mybatis核心配置文件中配置PageHelper插件</p><p>③测试分页数据获取</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 分页助手 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.jsqlparser<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsqlparser<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2.在mybatis核心配置文件中配置PageHelper插件</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意：分页助手的插件  配置在通用馆mapper之前 --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><h1 id="注意：当使用pageHelper版本为5-0以上的时候，配置文件中不能使用以下配置："><a href="#注意：当使用pageHelper版本为5-0以上的时候，配置文件中不能使用以下配置：" class="headerlink" title="注意：当使用pageHelper版本为5.0以上的时候，配置文件中不能使用以下配置："></a><em>注意：当使用pageHelper版本为5.0以上的时候，配置文件中不能使用以下配置：</em></h1><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 注意：分页助手的插件  配置在通用馆mapper之前 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 指定方言 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><p>因为MyBatis实现插件原理是底层通过intercepto接口，而pageHelper5.0以上版本是通过PageInterceptor类继承的intercepto </p><p><img src="D:\Hexo\source_posts\MyBatis的学习笔记\pageHelper.png" alt="pageHelper">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用spring+springMvc做的小案例</title>
    <link href="/2020/09/03/%E7%94%A8spring-springMvc%E5%81%9A%E7%9A%84%E5%B0%8F%E6%A1%88%E4%BE%8B/"/>
    <url>/2020/09/03/%E7%94%A8spring-springMvc%E5%81%9A%E7%9A%84%E5%B0%8F%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>#需要运用spring&amp;springMVC等知识<br>##经过为期5天的学习，基本掌握渐显的spring&amp;springmvc框架知识，了解了一些框架的基本原理，首先spring需要进行配置文件，配置bean对象，当我们进行三层架构时，web可用注解controle servie层和dao层进行配置文件时，需要无参构造，或者使其setter方法，依赖注入。在最项目中尽可能的代码解耦，<br>###1.导入所需的的工作环境<br>2.配置Maven导入所需的jar包坐标<br>3.分析流程图<br>4.熟练运用三层架构思想<br>5.CRUD逐个解决<br>6.前端数据交互等等<br>####总结，基本掌握一些框架知识，但不能完全独立写出代码流程，crud也不是完全掌握，需要今后多做练习，进行反复嵌套知识，形成一个流程网。。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/08/27/titleHello/"/>
    <url>/2020/08/27/titleHello/</url>
    
    <content type="html"><![CDATA[<p>title:Hello</p><p>date: 2020-08-27 19:57:05</p><p>时间从不说话，却回答了所有问题</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/27/hello-world/"/>
    <url>/2020/08/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
